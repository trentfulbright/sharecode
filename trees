//ï¿½ A+ Computer Science  -  www.apluscompsci.com
//Name -  
//Date -
//Class - 
//Lab  -

import static java.lang.System.*;
import java.util.LinkedList;

public class BinarySearchTree
{
	private TreeNode root;
	int NodeCount;

	public BinarySearchTree()
	{
		root = null;
	}

	public void add(Comparable val)
	{
		root = add(val, root);
	}

	private TreeNode add(Comparable val, TreeNode tree)
	{
		NodeCount++;
	   if(tree == null)
			tree = new TreeNode(val);
		
		Comparable treeValue = tree.getValue();
		int dirTest = val.compareTo(treeValue);
		
		if(dirTest < 0)
			tree.setLeft(add(val, tree.getLeft()));
		else if(dirTest > 0)
			tree.setRight(add(val, tree.getRight()));
		
		return tree;
	}

   public void inOrder()
	{
		inOrder(root);
		System.out.println("\n");
	}

	private void inOrder(TreeNode tree)
	{
		if (tree != null){
			inOrder(tree.getLeft());
			System.out.print(tree.getValue() + " ");
			inOrder(tree.getRight());
		}
	}



	// preOrder
	private void preOrder(TreeNode tree){
		if(tree != null){
			System.out.print(tree.getValue() + " ");
			preOrder(tree.getLeft());
			preOrder(tree.getRight());
		}
	}
	
	// postOrder
	private void postOrder(TreeNode tree){
		if(tree != null){
			postOrder(tree.getLeft());
			postOrder(tree.getRight());
			System.out.print(tree.getValue() + " ");
		}
	}
	
	// revOrder
	private void revOrder(TreeNode tree){
		if(tree != null){
			revOrder(tree.getRight());
			System.out.print(tree.getValue() + " ");
			revOrder(tree.getLeft());
		}
	}
	
	// levelOrder - use a queue
	private void levelOrder(TreeNode tree){
		LinkedList<Comparable> nums = new LinkedList();
		TreeNode cur = tree;
		

	}


	
	// zigzagOrder - hint below but could be solved in a different manner
	// loop thru a stack and load all nodes to a new stack(loading is based on direction)
	// set new stack to old and repeat



	// getNumLevels do before height

	public int getNumLevels(TreeNode tree){
		if(tree == null){
			return 0;
		}
		else{
			int numLeft = getNumLevels(tree.getLeft());
			int numRight = getNumLevels(tree.getRight());
			if(numLeft > numRight){
				return 1 + numLeft;
			}
			else{
				return 1 + numRight;
			}
		}

	}

	// getNumLeaves

	
	// getWidth - insure this works right for the 2nd test case

	// getHeight
	public int getHeight(TreeNode tree){
		return getNumLevels(tree) - 1;
	}
	
	// getNumNodes
	public int getNumNodes(TreeNode tree){
		return NodeCount;
	}


	
	// isFull
		
	// contains
	public Boolean contains(Comparable s){
		TreeNode cur = root;
		while(cur != null){
			if(cur.getValue().compareTo(s)==0){
				return true;
			}
			if(cur.getValue().compareTo(s)<0){
				cur = cur.getLeft();
			}
			else if(cur.getValue().compareTo(s)>0){
				cur = cur.getRight();
			}
		}
		return false;
	}


	// getSmallest
	public TreeNode getSmallest(TreeNode node){
		TreeNode newnode = node;
		while(newnode.getLeft() != null) {
			newnode = newnode.getLeft();
		}
		return newnode;
	}
	// getLargest
	public TreeNode getLargest(TreeNode node){
		TreeNode newnode = node;
		while(newnode.getRight() != null) {
			newnode = newnode.getRight();
		}
		return newnode;
	}
	
	// remove - follow adds set up very closely and check powerpoint if needed
	// 1st case = no children
	// 2nd case = one child
	// 3rd case two children
	public void remove(Comparable val, TreeNode tree){
		NodeCount--;


	}
	
	// ****BONUS**** 
	// display like a tree


	public String toString()
	{
		return "";
	}

	private String toString(TreeNode tree)
	{
		return "";
	}
}
